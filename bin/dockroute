#!/bin/bash
set -e

# dockroute - Local development proxy for Docker
# Eliminates port conflicts by routing via hostnames

VERSION="2.3.0"
PROXY_NAME="dockroute-traefik"
NETWORK_NAME="dockroute"

# Determine compose file location
# Priority: 1) Script's local share dir, 2) Homebrew share dir
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
if [[ -f "${SCRIPT_DIR}/share/docker-compose.yml" ]]; then
	COMPOSE_FILE="${SCRIPT_DIR}/share/docker-compose.yml"
elif [[ -n "${HOMEBREW_PREFIX:-}" && -f "${HOMEBREW_PREFIX}/share/dockroute/docker-compose.yml" ]]; then
	COMPOSE_FILE="${HOMEBREW_PREFIX}/share/dockroute/docker-compose.yml"
else
	echo "Error: Could not find docker-compose.yml"
	echo "Expected at: ${SCRIPT_DIR}/share/docker-compose.yml"
	exit 1
fi

# v1.x used "proxy" as the network name — migrate to "dockroute"
OLD_NETWORK_NAME="proxy"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

DOCKROUTE_DIR="${HOME}/.dockroute"
CERTS_DIR="${DOCKROUTE_DIR}/certs"
DYNAMIC_CONFIG="${DOCKROUTE_DIR}/traefik-dynamic.yml"
GENERATED_COMPOSE="${DOCKROUTE_DIR}/docker-compose.yml"

tls_active() {
	[[ -f "${CERTS_DIR}/cert.pem" && -f "${CERTS_DIR}/key.pem" ]]
}

generate_compose() {
	mkdir -p "$DOCKROUTE_DIR"

	if tls_active; then
		cat >"$GENERATED_COMPOSE" <<EOF
services:
  traefik:
    image: traefik:v3
    container_name: dockroute-traefik
    restart: unless-stopped
    command:
      - "--api.insecure=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.postgres.address=:5432"
      - "--providers.file.filename=/etc/traefik/dynamic.yml"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.dockroute.rule=Host(\`dockroute.localhost\`)"
      - "traefik.http.services.dockroute.loadbalancer.server.port=8080"
    ports:
      - "80:80"
      - "443:443"
      - "5432:5432"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ${CERTS_DIR}:/etc/traefik/certs:ro
      - ${DYNAMIC_CONFIG}:/etc/traefik/dynamic.yml:ro
    networks:
      - dockroute

networks:
  dockroute:
    external: true
EOF
	else
		cat >"$GENERATED_COMPOSE" <<EOF
services:
  traefik:
    image: traefik:v3
    container_name: dockroute-traefik
    restart: unless-stopped
    command:
      - "--api.insecure=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.dockroute.rule=Host(\`dockroute.localhost\`)"
      - "traefik.http.services.dockroute.loadbalancer.server.port=8080"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - dockroute

networks:
  dockroute:
    external: true
EOF
	fi
}

active_compose() {
	if [[ -f "$GENERATED_COMPOSE" ]]; then
		echo "$GENERATED_COMPOSE"
	else
		echo "$COMPOSE_FILE"
	fi
}

cmd_tls() {
	local subcmd="${2:-}"
	case "$subcmd" in
	setup) cmd_tls_setup ;;
	status) cmd_tls_status ;;
	remove) cmd_tls_remove ;;
	*)
		echo "Usage: dockroute tls <setup|status|remove>"
		echo ""
		echo "  setup   Generate TLS certificates for HTTPS and PostgreSQL routing"
		echo "  status  Show TLS certificate status"
		echo "  remove  Remove TLS certificates and config"
		;;
	esac
}

cmd_tls_setup() {
	# Check for mkcert
	if ! command -v mkcert >/dev/null 2>&1; then
		echo -e "${RED}Error: mkcert is not installed${NC}"
		echo ""
		echo "Install it with:"
		echo "  brew install mkcert    # macOS"
		echo "  apt install mkcert     # Debian/Ubuntu"
		echo ""
		echo "Then run: dockroute tls setup"
		exit 1
	fi

	# Install local CA if needed
	echo "Installing local CA (may prompt for password)..."
	mkcert -install

	# Generate certs
	mkdir -p "$CERTS_DIR"
	echo "Generating *.localhost certificate..."
	mkcert -cert-file "${CERTS_DIR}/cert.pem" -key-file "${CERTS_DIR}/key.pem" \
		"*.localhost" "localhost" 2>&1

	# Write Traefik dynamic config
	cat >"$DYNAMIC_CONFIG" <<'EOF'
tls:
  certificates:
    - certFile: /etc/traefik/certs/cert.pem
      keyFile: /etc/traefik/certs/key.pem
  stores:
    default:
      defaultCertificate:
        certFile: /etc/traefik/certs/cert.pem
        keyFile: /etc/traefik/certs/key.pem
http:
  middlewares:
    redirect-https:
      redirectScheme:
        scheme: https
EOF

	echo ""
	echo -e "${GREEN}✓ TLS configured${NC}"
	echo "  Certs:  ${CERTS_DIR}/"
	echo "  Config: ${DYNAMIC_CONFIG}"
	echo ""
	echo "Restart the proxy to activate HTTPS and PostgreSQL routing:"
	echo "  dockroute stop && dockroute start"
}

cmd_tls_status() {
	if tls_active; then
		echo -e "${GREEN}✓ TLS certificates installed${NC}"
		echo "  Cert: ${CERTS_DIR}/cert.pem"
		echo "  Key:  ${CERTS_DIR}/key.pem"

		# Show cert expiry
		if command -v openssl >/dev/null 2>&1; then
			local expiry
			expiry=$(openssl x509 -enddate -noout -in "${CERTS_DIR}/cert.pem" 2>/dev/null | cut -d= -f2)
			if [[ -n "$expiry" ]]; then
				echo "  Expires: $expiry"
			fi
		fi

		echo ""
		if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^${PROXY_NAME}$"; then
			# Check if postgres entrypoint is active
			local entrypoints
			entrypoints=$(curl -s http://dockroute.localhost/api/entrypoints 2>/dev/null || echo "")
			if echo "$entrypoints" | grep -q '"postgres"'; then
				echo -e "${GREEN}✓ PostgreSQL entrypoint active on port 5432${NC}"
			else
				echo -e "${YELLOW}! PostgreSQL entrypoint not active — restart proxy${NC}"
				echo "  dockroute stop && dockroute start"
			fi
		else
			echo "Proxy is not running. Start it with: dockroute start"
		fi
	else
		echo -e "${YELLOW}TLS certificates not installed${NC}"
		echo ""
		echo "Run: dockroute tls setup"
	fi
}

cmd_tls_remove() {
	local removed=false

	if [[ -d "$CERTS_DIR" ]]; then
		rm -rf "$CERTS_DIR"
		echo -e "${GREEN}✓ Removed certificates${NC}"
		removed=true
	fi

	if [[ -f "$DYNAMIC_CONFIG" ]]; then
		rm -f "$DYNAMIC_CONFIG"
		echo -e "${GREEN}✓ Removed dynamic config${NC}"
		removed=true
	fi

	if [[ -f "$GENERATED_COMPOSE" ]]; then
		rm -f "$GENERATED_COMPOSE"
		echo -e "${GREEN}✓ Removed generated compose file${NC}"
		removed=true
	fi

	if [[ "$removed" == true ]]; then
		echo ""
		echo "Restart the proxy to deactivate PostgreSQL routing:"
		echo "  dockroute stop && dockroute start"
	else
		echo "Nothing to remove — TLS is not configured"
	fi
}

migrate_network() {
	# Skip if old network doesn't exist
	if ! docker network inspect "$OLD_NETWORK_NAME" >/dev/null 2>&1; then
		return
	fi

	# Skip if new network already exists (migration already done)
	if docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
		echo -e "${YELLOW}Note: Old '$OLD_NETWORK_NAME' network still exists. Remove it with: docker network rm $OLD_NETWORK_NAME${NC}"
		return
	fi

	echo -e "${YELLOW}Migrating network '$OLD_NETWORK_NAME' → '$NETWORK_NAME'...${NC}"

	# Check if any containers are still connected
	CONNECTED=$(docker network inspect "$OLD_NETWORK_NAME" --format '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null | xargs)
	if [[ -n "$CONNECTED" ]]; then
		echo -e "${RED}Cannot migrate: containers are still connected to '$OLD_NETWORK_NAME':${NC}"
		echo "  $CONNECTED"
		echo ""
		echo "To migrate:"
		echo "  1. Stop those projects (docker compose down)"
		echo "  2. Update their docker-compose.yml: rename network 'proxy' → 'dockroute'"
		echo "  3. Run: docker network rm $OLD_NETWORK_NAME"
		echo "  4. Re-run: dockroute start"
		exit 1
	fi

	docker network rm "$OLD_NETWORK_NAME" >/dev/null
	echo -e "${GREEN}✓ Removed old '$OLD_NETWORK_NAME' network${NC}"
}

cmd_start() {
	migrate_network

	# Create network if needed
	if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
		echo "Creating Docker network '$NETWORK_NAME'..."
		docker network create "$NETWORK_NAME"
	fi

	# Generate compose file with current TLS state
	generate_compose
	local compose
	compose=$(active_compose)

	# Start Traefik if not running
	if ! docker ps --format '{{.Names}}' | grep -q "^${PROXY_NAME}$"; then
		# Check for port 5432 conflict when TLS is active
		if tls_active; then
			if lsof -i :5432 -sTCP:LISTEN >/dev/null 2>&1; then
				echo -e "${YELLOW}Warning: Port 5432 is already in use — PostgreSQL routing will not work${NC}"
				echo "  Stop the local PostgreSQL server and restart dockroute"
				echo ""
			fi
		fi

		echo -e "${GREEN}Starting dockroute...${NC}"
		docker compose -f "$compose" -p dockroute up -d
		echo ""
		echo -e "${GREEN}✓ Proxy running${NC}"
		echo "  Dashboard: http://dockroute.localhost"
		echo "  Projects:  http://<project>.localhost"
		if tls_active; then
			echo "  PostgreSQL: <project>-db.localhost:5432 (sslmode=require)"
		else
			echo ""
			echo -e "  Tip: Run ${GREEN}dockroute tls setup${NC} to enable PostgreSQL hostname routing"
		fi
	else
		echo -e "${GREEN}✓ Proxy already running${NC}"
	fi
}

cmd_stop() {
	if docker ps --format '{{.Names}}' | grep -q "^${PROXY_NAME}$"; then
		local compose
		compose=$(active_compose)
		echo "Stopping dockroute..."
		docker compose -f "$compose" -p dockroute down
		echo -e "${GREEN}✓ Stopped${NC}"
	else
		echo -e "${YELLOW}Proxy is not running${NC}"
	fi
}

cmd_status() {
	echo "dockroute status"
	echo "======================"
	echo ""

	if docker ps --format '{{.Names}}' | grep -q "^${PROXY_NAME}$"; then
		echo -e "${GREEN}✓ Proxy is running${NC}"
		echo ""
		echo "Dashboard: http://dockroute.localhost"

		# TLS status
		if tls_active; then
			echo -e "TLS: ${GREEN}configured${NC}"
		else
			echo -e "TLS: not configured (run ${GREEN}dockroute tls setup${NC} for HTTPS and PostgreSQL routing)"
		fi

		echo ""

		# Query Traefik API for HTTP routes (exclude internal Traefik routes)
		ROUTES=$(curl -s http://dockroute.localhost/api/http/routers 2>/dev/null || echo "")

		if [[ -n "$ROUTES" && "$ROUTES" != "[]" ]]; then
			# Split JSON into per-router fragments, excluding internal routes
			local fragments
			fragments=$(echo "$ROUTES" |
				sed 's/},/}\n/g' |
				grep -v '@internal')

			# Partition into HTTP and HTTPS routes based on "tls" presence
			local http_hosts https_hosts
			# shellcheck disable=SC2016
			http_hosts=$(echo "$fragments" |
				grep -v '"tls"' |
				grep -o 'Host(`[^`]*`)' |
				sed 's/Host(`\([^`]*\)`)/  http:\/\/\1/' |
				sort -u)

			# shellcheck disable=SC2016
			https_hosts=$(echo "$fragments" |
				grep '"tls"' |
				grep -o 'Host(`[^`]*`)' |
				sed 's/Host(`\([^`]*\)`)/  https:\/\/\1/' |
				sort -u)

			if [[ -n "$https_hosts" ]]; then
				echo "HTTPS routes:"
				echo "$https_hosts"
				echo ""
			fi

			echo "HTTP routes:"
			if [[ -n "$http_hosts" ]]; then
				echo "$http_hosts"
			else
				echo "  (none)"
			fi
		else
			echo "HTTP routes:"
			echo "  (none)"
		fi

		# Query Traefik API for TCP routes
		TCP_ROUTES=$(curl -s http://dockroute.localhost/api/tcp/routers 2>/dev/null || echo "")

		if [[ -n "$TCP_ROUTES" && "$TCP_ROUTES" != "[]" ]]; then
			# shellcheck disable=SC2016
			TCP_HOSTS=$(echo "$TCP_ROUTES" |
				sed 's/},/}\n/g' |
				grep -v '@internal' |
				grep -o 'HostSNI(`[^`]*`)' |
				grep -v 'HostSNI(`\*`)' |
				sed 's/HostSNI(`\([^`]*\)`)/  \1:5432 (sslmode=require)/' |
				sort -u)

			if [[ -n "$TCP_HOSTS" ]]; then
				echo ""
				echo "TCP routes (PostgreSQL):"
				echo "$TCP_HOSTS"
			fi
		fi
	else
		echo -e "${RED}✗ Proxy is not running${NC}"
		echo ""
		echo "Run: dockroute start"
	fi
}

cmd_logs() {
	if docker ps --format '{{.Names}}' | grep -q "^${PROXY_NAME}$"; then
		local compose
		compose=$(active_compose)
		docker compose -f "$compose" -p dockroute logs -f
	else
		echo -e "${RED}Proxy is not running${NC}"
		echo "Run: dockroute start"
		exit 1
	fi
}

cmd_ensure() {
	# Silent start for use in scripts - only outputs if starting
	migrate_network

	if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
		docker network create "$NETWORK_NAME" >/dev/null
	fi

	generate_compose
	local compose
	compose=$(active_compose)

	if ! docker ps --format '{{.Names}}' | grep -q "^${PROXY_NAME}$"; then
		echo "Starting dockroute..."
		docker compose -f "$compose" -p dockroute up -d >/dev/null
		echo -e "${GREEN}✓ Proxy started${NC}"
	fi
}

cmd_check() {
	local target="${2:-}"
	local compose_file=""

	# Find compose file
	if [[ -n "$target" ]]; then
		if [[ -f "$target" ]]; then
			compose_file="$target"
		else
			echo -e "${RED}Error: File not found: $target${NC}"
			exit 1
		fi
	else
		for name in docker-compose.yml compose.yml docker-compose.yaml compose.yaml; do
			if [[ -f "$name" ]]; then
				compose_file="$name"
				break
			fi
		done
		if [[ -z "$compose_file" ]]; then
			echo -e "${RED}Error: No compose file found${NC}"
			echo "Tried: docker-compose.yml, compose.yml, docker-compose.yaml, compose.yaml"
			echo "Usage: dockroute check [path]"
			exit 1
		fi
	fi

	# Derive project prefix from directory name
	local project_dir
	project_dir="$(cd "$(dirname "$compose_file")" && basename "$(pwd)")"
	local prefix
	prefix="$(echo "$project_dir" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')"

	echo "Checking $compose_file (prefix: $prefix)..."
	echo ""

	# Normalize compose file via docker compose config
	local config
	if ! config=$(docker compose -f "$compose_file" config 2>&1); then
		echo -e "${RED}Error: Failed to parse $compose_file${NC}"
		echo "$config"
		exit 1
	fi

	# --- Helpers for Bash 3 compatible key-value storage ---
	# Uses parallel arrays instead of associative arrays
	local _keys=()
	local _vals=()

	_kv_set() {
		local key="$1" val="$2" i
		for i in "${!_keys[@]}"; do
			if [[ "${_keys[i]}" == "$key" ]]; then
				_vals[i]="$val"
				return
			fi
		done
		_keys+=("$key")
		_vals+=("$val")
	}

	_kv_get() {
		local key="$1" i
		for i in "${!_keys[@]}"; do
			if [[ "${_keys[$i]}" == "$key" ]]; then
				echo "${_vals[$i]}"
				return
			fi
		done
	}

	_kv_append() {
		local key="$1" val="$2" i
		for i in "${!_keys[@]}"; do
			if [[ "${_keys[i]}" == "$key" ]]; then
				_vals[i]="${_vals[i]}${val}"
				return
			fi
		done
		_keys+=("$key")
		_vals+=("$val")
	}

	# Parse normalized YAML with a line-by-line state machine
	local errors=0
	local warnings=0
	local suggestions=0
	local services=()
	local has_dockroute_network=false

	local section=""
	local current_svc=""
	local in_labels=false
	local in_ports=false
	local in_networks=false
	local top_networks=false
	# Port parsing state: docker compose config outputs structured port blocks
	#   - mode: ingress
	#     target: 3000
	#     published: "3000"
	#     protocol: tcp
	local port_target=""
	local port_published=""

	while IFS= read -r line; do
		# Top-level sections (no leading whitespace)
		if [[ "$line" =~ ^[a-z] ]]; then
			# Flush pending port block before leaving services section
			if [[ "$in_ports" == true && -n "$port_target" && -n "$current_svc" ]]; then
				_kv_append "${current_svc}.ports" "${port_published}:${port_target}"$'\n'
				port_target=""
				port_published=""
			fi
			in_labels=false
			in_ports=false
			in_networks=false
			current_svc=""
			if [[ "$line" == "services:" ]]; then
				section="services"
				top_networks=false
			elif [[ "$line" == "networks:" ]]; then
				section="networks"
				top_networks=true
			else
				section=""
				top_networks=false
			fi
			continue
		fi

		# Top-level network: check for dockroute external
		if [[ "$top_networks" == true ]]; then
			if [[ "$line" =~ ^\ \ ([a-zA-Z0-9_-]+): ]]; then
				current_svc="${line##  }"
				current_svc="${current_svc%%:*}"
			elif [[ "$current_svc" == "dockroute" && "$line" =~ "external: true" ]]; then
				has_dockroute_network=true
			fi
			continue
		fi

		# Inside services section
		if [[ "$section" != "services" ]]; then
			continue
		fi

		# Service-level key (2-space indent in normalized output)
		if [[ "$line" =~ ^\ \ ([a-zA-Z0-9_-]+):$ ]]; then
			# Flush pending port block from previous service
			if [[ "$in_ports" == true && -n "$port_target" && -n "$current_svc" ]]; then
				_kv_append "${current_svc}.ports" "${port_published}:${port_target}"$'\n'
				port_target=""
				port_published=""
			fi
			current_svc="${BASH_REMATCH[1]}"
			services+=("$current_svc")
			_kv_set "${current_svc}.image" ""
			_kv_set "${current_svc}.ports" ""
			_kv_set "${current_svc}.has_traefik" "false"
			_kv_set "${current_svc}.has_tcp_traefik" "false"
			_kv_set "${current_svc}.has_https" "false"
			_kv_set "${current_svc}.traefik_labels" ""
			_kv_set "${current_svc}.networks" ""
			_kv_set "${current_svc}.has_build" "false"
			in_labels=false
			in_ports=false
			in_networks=false
			continue
		fi

		[[ -z "$current_svc" ]] && continue

		# Property-level key (4-space indent)
		if [[ "$line" =~ ^\ {4}([a-z_]+): ]]; then
			local prop="${BASH_REMATCH[1]}"
			# Flush pending port block before leaving ports section
			if [[ "$in_ports" == true && -n "$port_target" ]]; then
				_kv_append "${current_svc}.ports" "${port_published}:${port_target}"$'\n'
				port_target=""
				port_published=""
			fi
			in_labels=false
			in_ports=false
			in_networks=false
			case "$prop" in
			image)
				_kv_set "${current_svc}.image" "${line#*: }"
				;;
			labels) in_labels=true ;;
			ports) in_ports=true ;;
			networks) in_networks=true ;;
			build)
				_kv_set "${current_svc}.has_build" "true"
				;;
			esac
			continue
		fi

		# Labels: docker compose config outputs labels as a map (key: value),
		# not a list. e.g., "      traefik.enable: "true""
		if [[ "$in_labels" == true && "$line" =~ ^\ {6}([a-zA-Z0-9._-]+):\ (.+) ]]; then
			local lbl_key="${BASH_REMATCH[1]}"
			local lbl_val="${BASH_REMATCH[2]}"
			lbl_val="${lbl_val%\"}"
			lbl_val="${lbl_val#\"}"
			if [[ "$lbl_key" == "traefik.enable" && "$lbl_val" == "true" ]]; then
				_kv_set "${current_svc}.has_traefik" "true"
			fi
			if [[ "$lbl_key" =~ ^traefik\.tcp\. ]]; then
				_kv_set "${current_svc}.has_tcp_traefik" "true"
			fi
			if [[ "$lbl_key" =~ \.entrypoints$ && "$lbl_val" == "websecure" ]]; then
				_kv_set "${current_svc}.has_https" "true"
			fi
			_kv_append "${current_svc}.traefik_labels" "${lbl_key}=${lbl_val}"$'\n'
		fi

		# Ports: structured blocks from docker compose config
		# Each port entry starts with "- mode:" and has target/published on following lines
		if [[ "$in_ports" == true ]]; then
			if [[ "$line" =~ ^\ +- ]]; then
				# New port block — save previous if complete
				if [[ -n "$port_target" ]]; then
					_kv_append "${current_svc}.ports" "${port_published}:${port_target}"$'\n'
				fi
				port_target=""
				port_published=""
			elif [[ "$line" =~ ^\ +target:\ (.+) ]]; then
				port_target="${BASH_REMATCH[1]}"
			elif [[ "$line" =~ ^\ +published:\ (.+) ]]; then
				port_published="${BASH_REMATCH[1]}"
				port_published="${port_published%\"}"
				port_published="${port_published#\"}"
			fi
		fi

		# Networks: key-value pairs like "dockroute: null" or "default: null"
		if [[ "$in_networks" == true && "$line" =~ ^\ {6}([a-zA-Z0-9_-]+): ]]; then
			_kv_append "${current_svc}.networks" "${BASH_REMATCH[1]} "
		fi
	done <<<"$config"

	# Flush last port block if any
	if [[ "$in_ports" == true && -n "$port_target" ]]; then
		_kv_append "${current_svc}.ports" "${port_published}:${port_target}"$'\n'
	fi

	# Fallback: check raw compose file for dockroute network declaration
	# docker compose config strips unused external networks from output
	if [[ "$has_dockroute_network" == false ]]; then
		if grep -q 'dockroute' "$compose_file" 2>/dev/null &&
			grep -q 'external' "$compose_file" 2>/dev/null; then
			has_dockroute_network=true
		fi
	fi

	# Also check raw file for env var port patterns (docker compose config resolves them)
	local raw_content
	raw_content=$(cat "$compose_file")

	# Classify services
	local db_pattern='(postgres|mysql|mariadb|redis|memcached|mongo|elasticsearch|rabbitmq|mssql|valkey)'
	local support_pattern='(mailhog|mailpit|minio|adminer|phpmyadmin|pgadmin|redisinsight|soketi)'
	local web_ports_pattern='(3000|8080|8000|4200|5173|5000|4000|8888|9000):'

	for svc in "${services[@]}"; do
		local img
		img=$(_kv_get "${svc}.image")
		if [[ "$img" =~ $db_pattern ]]; then
			_kv_set "${svc}.type" "database"
		elif [[ "$img" =~ $support_pattern ]]; then
			_kv_set "${svc}.type" "support"
		elif [[ "$(_kv_get "${svc}.has_traefik")" == true ]]; then
			_kv_set "${svc}.type" "web"
		elif [[ "$(_kv_get "${svc}.has_build")" == true ]]; then
			_kv_set "${svc}.type" "web"
		elif [[ "$(_kv_get "${svc}.ports")" =~ $web_ports_pattern ]]; then
			_kv_set "${svc}.type" "web"
		else
			_kv_set "${svc}.type" "unknown"
		fi
	done

	# Run checks per service
	local need_suggestion=false

	for svc in "${services[@]}"; do
		local issues=""
		local type
		type=$(_kv_get "${svc}.type")
		local has_ports=false
		local has_traefik
		has_traefik=$(_kv_get "${svc}.has_traefik")
		local on_dockroute=false
		local svc_ports_val
		svc_ports_val=$(_kv_get "${svc}.ports")
		local svc_nets_val
		svc_nets_val=$(_kv_get "${svc}.networks")

		[[ -n "$svc_ports_val" ]] && has_ports=true
		[[ "$svc_nets_val" == *dockroute* ]] && on_dockroute=true

		# W1: Web/support service has ports but no Traefik labels
		if [[ ("$type" == "web" || "$type" == "support") && "$has_ports" == true && "$has_traefik" == false ]]; then
			local port_list
			port_list=$(echo -n "$svc_ports_val" | tr '\n' ', ' | sed 's/,$//')
			issues+="${RED}✗${NC} Has ports [$port_list] but no Traefik labels"$'\n'
			warnings=$((warnings + 1))
			need_suggestion=true
		fi

		# W2: Service has Traefik labels AND ports simultaneously
		if [[ "$has_traefik" == true && "$has_ports" == true ]]; then
			issues+="${YELLOW}!${NC} Has Traefik labels but still exposes ports — remove ports"$'\n'
			warnings=$((warnings + 1))
			need_suggestion=true
		fi

		# W3: Service has Traefik labels but not on dockroute network
		if [[ "$has_traefik" == true && "$on_dockroute" == false ]]; then
			issues+="${RED}✗${NC} Has Traefik labels but missing dockroute network"$'\n'
			errors=$((errors + 1))
			need_suggestion=true
		fi

		# D1: Database/cache exposes ports
		if [[ "$type" == "database" && "$has_ports" == true ]]; then
			local has_tcp
			has_tcp=$(_kv_get "${svc}.has_tcp_traefik")
			local svc_img
			svc_img=$(_kv_get "${svc}.image")
			local is_postgres=false
			[[ "$svc_img" =~ postgres ]] && is_postgres=true

			# Check raw compose file for env var pattern (docker compose config resolves variables)
			local uses_env_var=false
			# shellcheck disable=SC2016
			if echo "$raw_content" | grep -A5 "^  ${svc}:" | grep -q '${'; then
				uses_env_var=true
			fi
			if [[ "$has_tcp" == true ]]; then
				issues+="${YELLOW}!${NC} Has TCP labels but still exposes ports — remove ports"$'\n'
				warnings=$((warnings + 1))
				need_suggestion=true
			elif [[ "$is_postgres" == true ]]; then
				local port_list
				port_list=$(echo -n "$svc_ports_val" | tr '\n' ', ' | sed 's/,$//')
				issues+="${YELLOW}!${NC} Exposes port [$port_list] — use TCP labels for hostname routing (dockroute tls setup)"$'\n'
				suggestions=$((suggestions + 1))
				need_suggestion=true
			elif [[ "$uses_env_var" == true ]]; then
				issues+="${GREEN}✓${NC} Uses env var pattern for port access"$'\n'
			else
				local port_list
				port_list=$(echo -n "$svc_ports_val" | tr '\n' ', ' | sed 's/,$//')
				local svc_name
				svc_name=$(_kv_get "${svc}.image")
				svc_name="${svc_name%%:*}"
				svc_name="${svc_name##*/}"
				issues+="${YELLOW}!${NC} Exposes port [$port_list] — remove ports (use ${svc_name}://${svc}:${port_list##*:} internally)"$'\n'
				suggestions=$((suggestions + 1))
				need_suggestion=true
			fi
		fi

		# R1: Router name is generic — collision risk
		if [[ "$has_traefik" == true ]]; then
			local labels
			labels=$(_kv_get "${svc}.traefik_labels")
			local router_name=""
			while IFS= read -r lbl; do
				if [[ "$lbl" =~ traefik\.http\.routers\.([^.]+)\. ]]; then
					router_name="${BASH_REMATCH[1]}"
					break
				fi
			done <<<"$labels"
			if [[ -n "$router_name" ]]; then
				case "$router_name" in
				app | web | api | server | frontend | backend | service)
					issues+="${YELLOW}!${NC} Router name '$router_name' is generic — use '${prefix}' or '${prefix}-${svc}' to avoid collisions"$'\n'
					warnings=$((warnings + 1))
					;;
				esac
			fi
		fi

		# R2: Hostname uses nested subdomain instead of flat
		if [[ "$has_traefik" == true ]]; then
			local labels
			labels=$(_kv_get "${svc}.traefik_labels")
			# Store regex in variable — backticks in [[ =~ ]] are interpreted as command substitution
			# shellcheck disable=SC2016
			local nested_re='Host\(`([^.]+)\.([^.]+)\.localhost`\)'
			while IFS= read -r lbl; do
				if [[ "$lbl" =~ $nested_re ]]; then
					local sub="${BASH_REMATCH[1]}"
					local parent="${BASH_REMATCH[2]}"
					issues+="${YELLOW}!${NC} Nested subdomain '${sub}.${parent}.localhost' — use '${parent}-${sub}.localhost' instead"$'\n'
					warnings=$((warnings + 1))
				fi
			done <<<"$labels"
		fi

		# S1: TLS active but web/support service not using HTTPS
		if tls_active; then
			local has_https
			has_https=$(_kv_get "${svc}.has_https")
			if [[ ("$type" == "web" || "$type" == "support") && "$has_traefik" == true && "$has_https" == false ]]; then
				issues+="ℹ TLS is active — HTTPS available (add entrypoints=websecure + tls=true)"$'\n'
				suggestions=$((suggestions + 1))
			fi
		fi

		# T1: TCP router uses HostSNI(*) — only supports one db at a time
		local has_tcp
		has_tcp=$(_kv_get "${svc}.has_tcp_traefik")
		if [[ "$has_tcp" == true ]]; then
			local labels
			labels=$(_kv_get "${svc}.traefik_labels")
			# shellcheck disable=SC2016
			local hostsni_wildcard_re='HostSNI\(`\*`\)'
			while IFS= read -r lbl; do
				if [[ "$lbl" =~ $hostsni_wildcard_re ]]; then
					issues+="${YELLOW}!${NC} TCP router uses HostSNI(\`*\`) — use HostSNI(\`${prefix}-${svc}.localhost\`) for multi-project routing"$'\n'
					warnings=$((warnings + 1))
					need_suggestion=true
					break
				fi
			done <<<"$labels"
		fi

		# T2: TCP router name is generic — collision risk
		if [[ "$has_tcp" == true ]]; then
			local labels
			labels=$(_kv_get "${svc}.traefik_labels")
			local tcp_router_name=""
			while IFS= read -r lbl; do
				if [[ "$lbl" =~ traefik\.tcp\.routers\.([^.]+)\. ]]; then
					tcp_router_name="${BASH_REMATCH[1]}"
					break
				fi
			done <<<"$labels"
			if [[ -n "$tcp_router_name" ]]; then
				case "$tcp_router_name" in
				db | postgres | postgresql | database | pg)
					issues+="${YELLOW}!${NC} TCP router name '$tcp_router_name' is generic — use '${prefix}-${svc}' to avoid collisions"$'\n'
					warnings=$((warnings + 1))
					;;
				esac
			fi
		fi

		# T3: TCP service has labels but missing dockroute network
		if [[ "$has_tcp" == true && "$on_dockroute" == false ]]; then
			issues+="${RED}✗${NC} Has TCP labels but missing dockroute network"$'\n'
			errors=$((errors + 1))
			need_suggestion=true
		fi

		_kv_set "${svc}.issues" "$issues"
	done

	# N1: Missing dockroute network declaration
	local network_error=false
	if [[ "$has_dockroute_network" == false ]]; then
		network_error=true
		errors=$((errors + 1))
		need_suggestion=true
	fi

	# Print per-service results
	for svc in "${services[@]}"; do
		local issues
		issues=$(_kv_get "${svc}.issues")
		echo "  ${svc}:"
		if [[ -n "$issues" ]]; then
			while IFS= read -r issue; do
				[[ -z "$issue" ]] && continue
				echo -e "    ${issue}"
			done <<<"$issues"
		else
			echo -e "    ${GREEN}✓${NC} No issues"
		fi
		echo ""
	done

	if [[ "$network_error" == true ]]; then
		echo -e "  ${RED}✗${NC} Missing dockroute network declaration"
		echo ""
	fi

	# Summary
	local total=$((errors + warnings + suggestions))
	if [[ $total -eq 0 ]]; then
		echo -e "${GREEN}✓ All checks passed${NC}"
		return 0
	fi

	local summary=""
	[[ $errors -gt 0 ]] && summary+="$errors error(s)"
	[[ $warnings -gt 0 ]] && {
		[[ -n "$summary" ]] && summary+=", "
		summary+="$warnings warning(s)"
	}
	[[ $suggestions -gt 0 ]] && {
		[[ -n "$summary" ]] && summary+=", "
		summary+="$suggestions suggestion(s)"
	}
	echo "Found $summary"

	# Generate suggestion block
	if [[ "$need_suggestion" == true ]]; then
		echo ""
		echo "Suggested dockroute configuration:"
		echo "─────────────────────────────────────"
		echo "services:"

		for svc in "${services[@]}"; do
			local type
			type=$(_kv_get "${svc}.type")
			local has_ports=false
			local has_traefik
			has_traefik=$(_kv_get "${svc}.has_traefik")
			local on_dockroute=false
			local svc_ports_val
			svc_ports_val=$(_kv_get "${svc}.ports")
			local svc_nets_val
			svc_nets_val=$(_kv_get "${svc}.networks")
			local issues
			issues=$(_kv_get "${svc}.issues")

			[[ -n "$svc_ports_val" ]] && has_ports=true
			[[ "$svc_nets_val" == *dockroute* ]] && on_dockroute=true

			# Skip services with no issues
			if [[ -z "$issues" ]]; then
				echo "  $svc:"
				echo "    # ✓ No changes needed"
				continue
			fi

			echo "  $svc:"
			echo "    # ... your existing config ..."

			# Suggest Traefik labels for web/support services without them
			if [[ ("$type" == "web" || "$type" == "support") && "$has_traefik" == false ]]; then
				local router_name="${prefix}"
				[[ "$svc" != "app" && "$svc" != "web" ]] && router_name="${prefix}-${svc}"
				local hostname="${router_name}.localhost"

				# Detect the container port from existing port mapping
				local container_port=""
				if [[ "$has_ports" == true ]]; then
					local first_port
					first_port=$(echo "$svc_ports_val" | head -1)
					container_port="${first_port##*:}"
				fi

				echo "    labels:"
				echo "      - \"traefik.enable=true\""
				echo "      - \"traefik.http.routers.${router_name}.rule=Host(\`${hostname}\`)\""
				if tls_active; then
					echo "      - \"traefik.http.routers.${router_name}.entrypoints=websecure\""
					echo "      - \"traefik.http.routers.${router_name}.tls=true\""
				fi
				if [[ -n "$container_port" ]]; then
					echo "      - \"traefik.http.services.${router_name}.loadbalancer.server.port=${container_port}\""
				else
					echo "      - \"traefik.http.services.${router_name}.loadbalancer.server.port=<port>\""
				fi
				echo "    networks:"
				echo "      - dockroute"
				echo "      - default"
			fi

			# Suggest TCP labels for PostgreSQL services
			local svc_img
			svc_img=$(_kv_get "${svc}.image")
			local has_tcp
			has_tcp=$(_kv_get "${svc}.has_tcp_traefik")
			if [[ "$type" == "database" && "$svc_img" =~ postgres && "$has_tcp" == false ]]; then
				local tcp_name="${prefix}-${svc}"
				echo "    labels:"
				echo "      - \"traefik.enable=true\""
				echo "      - \"traefik.tcp.routers.${tcp_name}.rule=HostSNI(\`${tcp_name}.localhost\`)\""
				echo "      - \"traefik.tcp.routers.${tcp_name}.entrypoints=postgres\""
				echo "      - \"traefik.tcp.routers.${tcp_name}.tls=true\""
				echo "      - \"traefik.tcp.services.${tcp_name}.loadbalancer.server.port=5432\""
				echo "    networks:"
				echo "      - dockroute"
				echo "      - default"
				echo "    # Remove: ports"
				echo "    # Host access: psql \"host=${tcp_name}.localhost sslmode=require\""
			fi

			# Suggest network if has Traefik/TCP but missing dockroute
			if [[ ("$has_traefik" == true || "$has_tcp" == true) && "$on_dockroute" == false ]]; then
				# Only suggest if not already suggested above (postgres TCP suggestion includes networks)
				if ! [[ "$type" == "database" && "$svc_img" =~ postgres && "$has_tcp" == false ]]; then
					echo "    networks:"
					echo "      - dockroute"
					echo "      - default"
				fi
			fi

			# Suggest removing ports
			if [[ "$has_ports" == true ]]; then
				if [[ "$type" == "database" ]]; then
					# Skip port removal suggestion for postgres — already handled by TCP suggestion above
					if ! [[ "$svc_img" =~ postgres ]]; then
						local svc_name
						svc_name=$(_kv_get "${svc}.image")
						svc_name="${svc_name%%:*}"
						svc_name="${svc_name##*/}"
						local first_port
						first_port=$(echo "$svc_ports_val" | head -1)
						local container_port="${first_port##*:}"
						echo "    # Remove: ports"
						echo "    # Connect internally: ${svc_name}://${svc}:${container_port}"
					fi
				elif [[ "$has_traefik" == true || "$type" == "web" || "$type" == "support" ]]; then
					echo "    # Remove: ports"
				fi
			fi
		done

		if [[ "$network_error" == true ]]; then
			echo ""
			echo "networks:"
			echo "  dockroute:"
			echo "    external: true"
		fi

		echo "─────────────────────────────────────"
	fi

	return 1
}

cmd_version() {
	echo "dockroute v${VERSION}"
}

cmd_help() {
	echo "dockroute - Local development proxy for Docker"
	echo ""
	echo "Eliminates port conflicts by routing via hostnames."
	echo "Run multiple projects simultaneously, each accessible at:"
	echo "  http://<projectname>.localhost"
	echo ""
	echo "Usage: dockroute <command>"
	echo ""
	echo "Commands:"
	echo "  start       Start the proxy"
	echo "  stop        Stop the proxy"
	echo "  status      Show proxy status and routed services"
	echo "  check       Check a compose file for dockroute issues"
	echo "  logs        Follow proxy logs"
	echo "  ensure      Start proxy if not running (for scripts)"
	echo "  tls setup   Generate TLS certs for HTTPS and PostgreSQL routing"
	echo "  tls status  Show TLS certificate status"
	echo "  tls remove  Remove TLS certs and config"
	echo "  version     Show version"
	echo "  help        Show this help"
	echo ""
	echo "Project Setup (HTTP):"
	echo "  Add to your docker-compose.yml:"
	echo ""
	echo "    services:"
	echo "      app:"
	echo "        labels:"
	echo "          - \"traefik.enable=true\""
	echo "          - \"traefik.http.routers.myapp.rule=Host(\\\`myapp.localhost\\\`)\""
	echo "          - \"traefik.http.services.myapp.loadbalancer.server.port=3000\""
	echo "        networks:"
	echo "          - dockroute"
	echo "          - default"
	echo ""
	echo "    networks:"
	echo "      dockroute:"
	echo "        external: true"
	echo ""
	echo "HTTPS Setup (after 'dockroute tls setup'):"
	echo ""
	echo "    services:"
	echo "      app:"
	echo "        labels:"
	echo "          - \"traefik.enable=true\""
	echo "          - \"traefik.http.routers.myapp.rule=Host(\\\`myapp.localhost\\\`)\""
	echo "          - \"traefik.http.routers.myapp.entrypoints=websecure\""
	echo "          - \"traefik.http.routers.myapp.tls=true\""
	echo "          - \"traefik.http.services.myapp.loadbalancer.server.port=3000\""
	echo "        networks:"
	echo "          - dockroute"
	echo "          - default"
	echo ""
	echo "  Access at: https://myapp.localhost"
	echo ""
	echo "PostgreSQL Routing (after 'dockroute tls setup'):"
	echo ""
	echo "    services:"
	echo "      db:"
	echo "        image: postgres:16"
	echo "        labels:"
	echo "          - \"traefik.enable=true\""
	echo "          - \"traefik.tcp.routers.myapp-db.rule=HostSNI(\\\`myapp-db.localhost\\\`)\""
	echo "          - \"traefik.tcp.routers.myapp-db.entrypoints=postgres\""
	echo "          - \"traefik.tcp.routers.myapp-db.tls=true\""
	echo "          - \"traefik.tcp.services.myapp-db.loadbalancer.server.port=5432\""
	echo "        networks:"
	echo "          - dockroute"
	echo "          - default"
	echo ""
	echo "  Connect: psql \"host=myapp-db.localhost sslmode=require\""
	echo "  Drizzle: DATABASE_URL=postgres://user:pass@myapp-db.localhost:5432/db?sslmode=require"
}

case "${1:-}" in
start) cmd_start ;;
stop) cmd_stop ;;
status) cmd_status ;;
check) cmd_check "$@" ;;
logs) cmd_logs ;;
ensure) cmd_ensure ;;
tls) cmd_tls "$@" ;;
version) cmd_version ;;
-v) cmd_version ;;
--version) cmd_version ;;
help) cmd_help ;;
-h) cmd_help ;;
--help) cmd_help ;;
*) cmd_help ;;
esac
